<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>repograph.entities.graph.service API documentation</title>
<meta name="description" content="Graph entity application logic." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>repograph.entities.graph.service</code></h1>
</header>
<section id="section-intro">
<p>Graph entity application logic.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Graph entity application logic.
&#34;&#34;&#34;
# Base imports
import contextlib
import datetime
import json
import traceback
from logging import getLogger
import re
from sqlite3 import Connection
from typing import Dict, List, Optional
import sys

# pip imports
from py2neo import Transaction
from neo4j import Transaction as neo4jTransaction

# Model imports
from repograph.entities.graph.models.base import BaseSubgraph, Node, Relationship
from repograph.entities.graph.models.nodes import (
    Class,
    Docstring,
    Function,
    Module,
    Package,
    Repository,
    README,
)
from repograph.entities.graph.models.graph import (
    GraphSummary,
    CallGraph,
    CircularDependency,
    MissingRequirement,
)

# Graph entity imports
from repograph.entities.graph.repository import GraphRepository

# Metadata entity imports
from repograph.entities.metadata.models import Graph
from repograph.entities.metadata.service import MetadataService

# Exceptions
from repograph.entities.graph.exceptions import InvalidGraphNameError
from repograph.utils import JSONDict

# Configure logging
log = getLogger(&#34;repograph.entities.graph.service&#34;)


class GraphService:
    &#34;&#34;&#34;
    The GraphService class implements all application-logic related to the graph entity.
    &#34;&#34;&#34;

    repository: GraphRepository
    metadata: MetadataService

    def __init__(self, repository: GraphRepository, metadata: MetadataService):
        &#34;&#34;&#34;Constructor

        Args:
            repository (GraphRepository): The Neo4j graph repository.
            metadata (MetadataService): The metadata service.
        &#34;&#34;&#34;
        self.repository = repository
        self.metadata = metadata

    def create_graph(
        self,
        name: str,
        description: str,
        system_tx: neo4jTransaction,
        metadata_tx: Connection,
    ) -&gt; Graph:
        &#34;&#34;&#34;Create a new graph.

        Args:
            name:
            description:
            system_tx:
            metadata_tx:

        Returns:
            Graph: Created Graph object
        &#34;&#34;&#34;
        if not re.match(r&#34;^[a-z,A-Z,0-9][a-z,A-Z,0-9]{2,63}$&#34;, name.lower()):
            raise InvalidGraphNameError(name)

        graph = Graph(
            neo4j_name=name.lower(),
            name=name,
            description=description,
            created=datetime.datetime.now(),
        )

        self.repository.create_graph(graph.neo4j_name, system_tx)
        self.metadata.register_graph(graph, metadata_tx)

        return graph

    def delete_graph(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete a graph

        Args:
            name (str): Name of the graph to delete

        Returns:
            None
        &#34;&#34;&#34;
        self.repository.delete_graph(name)
        self.metadata.delete_graph(name)

    @contextlib.contextmanager
    def get_transaction(self, graph_name):
        &#34;&#34;&#34;Obtain a Neo4j transaction for a given graph.

        Args:
            graph_name (str): The name of the graph
        &#34;&#34;&#34;
        tx = self.repository.get_transaction(graph_name=graph_name)
        try:
            yield tx
            log.info(&#34;Committing changes to graph...&#34;)
            tx.commit()
            log.info(&#34;Done!&#34;)
        except Exception as e:
            log.error(&#34;An error occurred. Rolling back graph transaction!\n&#34; + str(e))
            traceback.print_exc()
            tx.rollback()

    @contextlib.contextmanager
    def get_system_transaction(self):
        tx = self.repository.get_driver_transaction()
        metadata_tx = self.metadata.get_transaction()
        try:
            yield tx, metadata_tx
            tx.commit()
            metadata_tx.commit()
        except Exception as e:
            log.error(
                &#34;An error occurred. Rolling back system graph and metadata transactions!\n%s&#34;,
                str(e),
            )
            tx.rollback()
            metadata_tx.rollback()
            raise e

    def add(self, *args: BaseSubgraph, tx: Transaction = None, graph_name=None):
        &#34;&#34;&#34;Add nodes/relationships to the graph

        Args:
            *args (BaseSubgraph): Nodes and/or relationships
            tx (Transaction): The optional transaction object to use
            graph_name (str): The optional graph name to obtain a transaction for if no tx is used.
        &#34;&#34;&#34;
        self.repository.add(*args, tx=tx, graph_name=graph_name)

    def bulk_add(
        self, nodes: List[Node], relationships: List[Relationship], graph_name: str
    ):
        &#34;&#34;&#34;Bulk add nodes and relationships.

        Args:
            nodes (List[Node]): Nodes to add.
            relationships (List[Relationship]): Relationships to add.
            graph_name (str): The optional graph name to obtain a transaction for.

        Return:
            None
        &#34;&#34;&#34;
        self.repository.add(*nodes, *relationships, graph_name=graph_name)

    def get_summary(self, graph_name: str) -&gt; GraphSummary:
        &#34;&#34;&#34;Calculate a summary of the graph.

        Args:
            graph_name (str): The graph name to get summary for.

        Return:
            GraphSummary
        &#34;&#34;&#34;
        if not self.repository.has_nodes(graph_name=graph_name):
            log.warning(&#34;Graph has no nodes&#34;)
            return GraphSummary()

        summary = GraphSummary(is_empty=False)

        # Nodes and relationships totals
        nodes, relationships = self.repository.get_number_of_nodes_and_relationships(
            graph_name=graph_name
        )
        summary.nodes_total = nodes
        summary.relationships_total = relationships

        # Repositories
        summary.repositories = len(
            self.repository.get_all_nodes_by_label(Repository, graph_name=graph_name)
        )

        # Packages
        summary.packages = len(
            self.repository.get_all_nodes_by_label(Package, graph_name=graph_name)
        )

        # Modules
        summary.modules = len(
            self.repository.get_all_nodes_by_label(Module, graph_name=graph_name)
        )

        # Classes
        summary.classes = len(
            self.repository.get_all_nodes_by_label(Class, graph_name=graph_name)
        )

        # Functions
        summary.functions = len(
            self.repository.get_all_nodes_by_label(Function, graph_name=graph_name)
        )

        # README
        summary.readmes = len(
            self.repository.get_all_nodes_by_label(README, graph_name=graph_name)
        )

        return summary

    def get_docstrings(self, graph: str) -&gt; List[Node]:
        &#34;&#34;&#34;Get Docstring nodes.

        Args:
            graph (str): Graph name to query.

        Returns:
            List[Node]
        &#34;&#34;&#34;
        return self.repository.get_all_nodes_by_label(Docstring, graph_name=graph)

    def get_function_summarizations(
        self, graph_name: str, repository_name: str = None
    ) -&gt; Dict[str, Function]:
        &#34;&#34;&#34;Converts all Function nodes into a list of tuples.

        Args:
            graph_name (str): The graph name to get function summarizations for.
            repository_name (str, optional): The specific repository within the
                                             graph to search against.

        Returns:
            List[Tuple[str, Function]
        &#34;&#34;&#34;
        if not repository_name:
            repository_name = &#34;.*&#34;

        nodes = self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:Docstring)-[:Documents]-(f:Function) WHERE n.summarization IS NOT NULL
            AND f.repository_name =~ &#39;{repository_name}&#39;
            RETURN n.summarization as `summarization`, f as `function`
            &#34;&#34;&#34;,
            graph_name=graph_name,
        )

        return dict(
            map(
                lambda x: (
                    x[&#34;summarization&#34;],
                    Function(identity=x[&#34;function&#34;].identity, **x[&#34;function&#34;]),
                ),
                nodes,
            )
        )

    def get_call_graph_by_id(self, node_id: int, graph_name: str) -&gt; CallGraph:
        &#34;&#34;&#34;Get the call graph for a Function node by its ID.

        Args:
            node_id (int): ID of the Function node.
            graph_name (str): The graph name to get function summarizations for.

        Returns:
            CallGraph
        &#34;&#34;&#34;
        results = self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (c:Function)-[r:Calls*0..1]-(f:Function)-[h:HasMethod|HasFunction]-(p)
            WHERE ID(f) = {node_id} RETURN f as `function`, c as `call`,
            r as `relationship`, p as `parent`, h as `has`, labels(p) as `parent_type`,
            labels(c) as `call_type`, type(h) as `has_type`
            &#34;&#34;&#34;,
            graph_name=graph_name,
        )

        if not results:
            return CallGraph()

        call_graph = CallGraph()

        call_graph.nodes.append(
            CallGraph.Node(
                id=results[0][&#34;function&#34;].identity,
                name=results[0][&#34;function&#34;][&#34;name&#34;],
                canonical_name=results[0][&#34;function&#34;][&#34;canonical_name&#34;],
                type=results[0][&#34;function&#34;][&#34;type&#34;],
            )
        )

        call_graph.nodes.append(
            CallGraph.Node(
                id=results[0][&#34;parent&#34;].identity,
                name=results[0][&#34;parent&#34;][&#34;name&#34;],
                canonical_name=results[0][&#34;parent&#34;][&#34;canonical_name&#34;],
                type=results[0][&#34;parent_type&#34;][0],
            )
        )

        call_graph.links.append(
            CallGraph.Relationship(
                from_id=results[0][&#34;parent&#34;].identity,
                to_id=results[0][&#34;function&#34;].identity,
                type=results[0][&#34;has_type&#34;],
            )
        )

        results = list(filter(lambda x: x[&#34;call&#34;].identity != node_id, results))
        if len(results) == 0:
            return call_graph

        call_graph.nodes.extend(
            list(
                map(
                    lambda res: CallGraph.Node(
                        id=res[&#34;call&#34;].identity,
                        name=(res[&#34;call&#34;][&#34;name&#34;]),
                        canonical_name=(
                            res[&#34;call&#34;][&#34;canonical_name&#34;]
                            if &#34;canonical_name&#34; in res
                            else res[&#34;call&#34;][&#34;name&#34;]
                        ),
                        type=res[&#34;call_type&#34;][0],
                    ),
                    results,
                )
            )
        )

        def parse_relationships(x):
            return list(
                map(
                    lambda y: CallGraph.Relationship(
                        from_id=y.start_node.identity,
                        to_id=y.end_node.identity,
                        type=&#34;Calls&#34;,
                    ),
                    x[&#34;relationship&#34;],
                )
            )

        call_graph.links.extend(
            [
                item
                for sublist in list(map(parse_relationships, results))
                for item in sublist
            ]
        )

        return call_graph

    def get_cyclical_dependencies(self, graph: str) -&gt; List[CircularDependency]:
        &#34;&#34;&#34;Get the number of cyclical dependencies in the specified graph.

        Args:
            graph (str): The name of the graph to check.

        Returns:
            List[CircularDependency]: The list of unique cyclical dependencies found.
        &#34;&#34;&#34;
        result = self.repository.execute_query(
            &#34;MATCH p=(n)-[:Imports|Calls*2..]-&gt;(n) RETURN nodes(p) as `nodes`&#34;,
            graph_name=graph,
        )

        cycles = set()

        for cycle in result:
            cycles.add(
                frozenset(
                    map(
                        lambda x: f&#34;{x[&#39;canonical_name&#39;]}.{x[&#39;extension&#39;]}&#34;,
                        cycle.get(&#34;nodes&#34;),
                    )
                )
            )

        return list(
            map(
                lambda c: CircularDependency(
                    Files=&#34; -&gt; &#34;.join(list(c) + [list(c)[0]]), Length=len(list(c))
                ),
                list(cycles),
            )
        )

    def get_missing_dependencies(self, graph: str) -&gt; List[MissingRequirement]:
        &#34;&#34;&#34;Get the number of dependencies that are missing from the requirements.

        Args:
            graph (str): The name of the graph to check.

        Returns:
            List[MissingRequirement]: The list of missing requirements found.
        &#34;&#34;&#34;
        result = self.repository.execute_query(
            &#34;MATCH (n:Package|Module) WHERE (n.inferred) = true AND  NOT (n)&lt;-[*]-()  &#34;
            &#34;RETURN DISTINCT n.canonical_name as `name`, n.repository_name as `repository`&#34;,
            graph_name=graph,
        )

        result = list(
            filter(lambda n: n[&#34;name&#34;] not in sys.stdlib_module_names, list(result))
        )

        return list(
            map(
                lambda n: MissingRequirement(
                    Package=n[&#34;name&#34;], Repository=n[&#34;repository&#34;]
                ),
                list(result),
            )
        )

    def get_readme_files(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get README files for the given graph

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        result = self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:README)-[:Contains*1..]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
            RETURN r.name as `Repository`, n.path as `File`, n.content as `Contents`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        return result

    def get_requirements(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the requirements for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (r:Repository)-[s:Requires]-&gt;(d) WHERE r.name =~ &#39;{repository}&#39;
            RETURN r.name as `Repository`, d.name as `Dependency`, s.specifications as `Specifications`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_licenses(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the licenses for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:License)-[]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
            RETURN r.name as `Repository`, n.license_type as `License`,
            n.confidence as `Confidence`, n.text as `Content`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_docstrings_full(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the docstrings and functions for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:Docstring)-[Documents]-(f:Function)-[:HasFunction|HasMethod]-()-[:Contains*1..]-(r:Repository)
            WHERE (n.short_description IS NOT NULL OR n.long_description IS NOT NULL)
            AND r.name =~ &#39;{repository}&#39; RETURN r.name as `Repository`, f.name as `Function Name`,
            n.short_description as `Docstring Summary`, n.long_description as `Doctring Body`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_summarizations(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the summarizations and functions for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:Docstring)-[:Documents]-(f)-[:HasFunction|HasMethod]-()-[:Contains*1..]-(r:Repository)
            WHERE n.summarization IS NOT NULL AND r.name =~ &#39;{repository}&#39;
            RETURN r.name as `Repository`, f.name as `Function`,
            n.summarization as `Summarization`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_files(self, graph: str, repository: Optional[str] = None) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the file names for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (m:Module)-[:Contains*1..]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
            RETURN m.name + &#39;.&#39; + m.extension as `Filename`, r.name as `Repository`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_functions_and_classes(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the function and class names for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:Class|Function)-[:HasFunction|HasMethod*0..]-()-[:Contains*1..]-(r:Repository)
            WHERE r.name =~ &#39;{repository}&#39; RETURN r.name as `Repository`, n.name as `Name`, labels(n) as `Type`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_repository_metadata(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the metadata for the given repository.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        result = self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (r:Repository) WHERE r.name =~ &#39;{repository}&#39;
            RETURN DISTINCT r.name as `name`, properties(r) as `properties`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        return list(
            map(
                lambda x: {
                    &#34;Repository&#34;: x[&#34;name&#34;],
                    &#34;Metadata&#34;: json.dumps(x[&#34;properties&#34;], sort_keys=True),
                },
                result,
            )
        )

    def get_repository_names(self, graph: str) -&gt; List[str]:
        &#34;&#34;&#34;Get the names of repositories in the graph.

        Args:
            graph (str): The graph to query

        Returns:
            List[str]
        &#34;&#34;&#34;
        result = self.repository.execute_query(
            &#34;&#34;&#34;
            MATCH (n:Repository) RETURN COLLECT(n.name) as `Repositories`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        return list(
            set([item for sublist in result for item in sublist[&#34;Repositories&#34;]])
        )

    def get_graph(self, graph: str) -&gt; CallGraph:
        &#34;&#34;&#34;Get an entire graph. All nodes and relationships

        Args:
            graph (str): Name of graph to fetch

        Returns:
            CallGraph
        &#34;&#34;&#34;
        call_graph = CallGraph()

        relationships = self.repository.execute_query(
            &#34;&#34;&#34;
            MATCH ()-[r]-() RETURN DISTINCT r as `relationship`, type(r) as `type`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        nodes = self.repository.execute_query(
            &#34;&#34;&#34;
            MATCH (n) RETURN DISTINCT id(n) as `identity`, 
            COALESCE(n.name, n.path, n.summarization, n.short_description, n.long_description, n.license_type) as `name`,
            labels(n) as `type`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        call_graph.links.extend(
            list(
                map(
                    lambda rel: CallGraph.Relationship(
                        from_id=rel[&#34;relationship&#34;].start_node.identity,
                        to_id=rel[&#34;relationship&#34;].end_node.identity,
                        type=rel[&#34;type&#34;],
                    ),
                    relationships,
                )
            )
        )

        call_graph.nodes.extend(
            list(
                map(
                    lambda node: CallGraph.Node(
                        id=node[&#34;identity&#34;],
                        name=node[&#34;name&#34;],
                        canonical_name=&#34;&#34;,
                        type=node[&#34;type&#34;][0],
                    ),
                    nodes,
                )
            )
        )

        return call_graph</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="repograph.entities.graph.service.GraphService"><code class="flex name class">
<span>class <span class="ident">GraphService</span></span>
<span>(</span><span>repository: <a title="repograph.entities.graph.repository.GraphRepository" href="repository.html#repograph.entities.graph.repository.GraphRepository">GraphRepository</a>, metadata: <a title="repograph.entities.metadata.service.MetadataService" href="../metadata/service.html#repograph.entities.metadata.service.MetadataService">MetadataService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The GraphService class implements all application-logic related to the graph entity.</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>repository</code></strong> :&ensp;<code>GraphRepository</code></dt>
<dd>The Neo4j graph repository.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataService</code></dt>
<dd>The metadata service.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphService:
    &#34;&#34;&#34;
    The GraphService class implements all application-logic related to the graph entity.
    &#34;&#34;&#34;

    repository: GraphRepository
    metadata: MetadataService

    def __init__(self, repository: GraphRepository, metadata: MetadataService):
        &#34;&#34;&#34;Constructor

        Args:
            repository (GraphRepository): The Neo4j graph repository.
            metadata (MetadataService): The metadata service.
        &#34;&#34;&#34;
        self.repository = repository
        self.metadata = metadata

    def create_graph(
        self,
        name: str,
        description: str,
        system_tx: neo4jTransaction,
        metadata_tx: Connection,
    ) -&gt; Graph:
        &#34;&#34;&#34;Create a new graph.

        Args:
            name:
            description:
            system_tx:
            metadata_tx:

        Returns:
            Graph: Created Graph object
        &#34;&#34;&#34;
        if not re.match(r&#34;^[a-z,A-Z,0-9][a-z,A-Z,0-9]{2,63}$&#34;, name.lower()):
            raise InvalidGraphNameError(name)

        graph = Graph(
            neo4j_name=name.lower(),
            name=name,
            description=description,
            created=datetime.datetime.now(),
        )

        self.repository.create_graph(graph.neo4j_name, system_tx)
        self.metadata.register_graph(graph, metadata_tx)

        return graph

    def delete_graph(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete a graph

        Args:
            name (str): Name of the graph to delete

        Returns:
            None
        &#34;&#34;&#34;
        self.repository.delete_graph(name)
        self.metadata.delete_graph(name)

    @contextlib.contextmanager
    def get_transaction(self, graph_name):
        &#34;&#34;&#34;Obtain a Neo4j transaction for a given graph.

        Args:
            graph_name (str): The name of the graph
        &#34;&#34;&#34;
        tx = self.repository.get_transaction(graph_name=graph_name)
        try:
            yield tx
            log.info(&#34;Committing changes to graph...&#34;)
            tx.commit()
            log.info(&#34;Done!&#34;)
        except Exception as e:
            log.error(&#34;An error occurred. Rolling back graph transaction!\n&#34; + str(e))
            traceback.print_exc()
            tx.rollback()

    @contextlib.contextmanager
    def get_system_transaction(self):
        tx = self.repository.get_driver_transaction()
        metadata_tx = self.metadata.get_transaction()
        try:
            yield tx, metadata_tx
            tx.commit()
            metadata_tx.commit()
        except Exception as e:
            log.error(
                &#34;An error occurred. Rolling back system graph and metadata transactions!\n%s&#34;,
                str(e),
            )
            tx.rollback()
            metadata_tx.rollback()
            raise e

    def add(self, *args: BaseSubgraph, tx: Transaction = None, graph_name=None):
        &#34;&#34;&#34;Add nodes/relationships to the graph

        Args:
            *args (BaseSubgraph): Nodes and/or relationships
            tx (Transaction): The optional transaction object to use
            graph_name (str): The optional graph name to obtain a transaction for if no tx is used.
        &#34;&#34;&#34;
        self.repository.add(*args, tx=tx, graph_name=graph_name)

    def bulk_add(
        self, nodes: List[Node], relationships: List[Relationship], graph_name: str
    ):
        &#34;&#34;&#34;Bulk add nodes and relationships.

        Args:
            nodes (List[Node]): Nodes to add.
            relationships (List[Relationship]): Relationships to add.
            graph_name (str): The optional graph name to obtain a transaction for.

        Return:
            None
        &#34;&#34;&#34;
        self.repository.add(*nodes, *relationships, graph_name=graph_name)

    def get_summary(self, graph_name: str) -&gt; GraphSummary:
        &#34;&#34;&#34;Calculate a summary of the graph.

        Args:
            graph_name (str): The graph name to get summary for.

        Return:
            GraphSummary
        &#34;&#34;&#34;
        if not self.repository.has_nodes(graph_name=graph_name):
            log.warning(&#34;Graph has no nodes&#34;)
            return GraphSummary()

        summary = GraphSummary(is_empty=False)

        # Nodes and relationships totals
        nodes, relationships = self.repository.get_number_of_nodes_and_relationships(
            graph_name=graph_name
        )
        summary.nodes_total = nodes
        summary.relationships_total = relationships

        # Repositories
        summary.repositories = len(
            self.repository.get_all_nodes_by_label(Repository, graph_name=graph_name)
        )

        # Packages
        summary.packages = len(
            self.repository.get_all_nodes_by_label(Package, graph_name=graph_name)
        )

        # Modules
        summary.modules = len(
            self.repository.get_all_nodes_by_label(Module, graph_name=graph_name)
        )

        # Classes
        summary.classes = len(
            self.repository.get_all_nodes_by_label(Class, graph_name=graph_name)
        )

        # Functions
        summary.functions = len(
            self.repository.get_all_nodes_by_label(Function, graph_name=graph_name)
        )

        # README
        summary.readmes = len(
            self.repository.get_all_nodes_by_label(README, graph_name=graph_name)
        )

        return summary

    def get_docstrings(self, graph: str) -&gt; List[Node]:
        &#34;&#34;&#34;Get Docstring nodes.

        Args:
            graph (str): Graph name to query.

        Returns:
            List[Node]
        &#34;&#34;&#34;
        return self.repository.get_all_nodes_by_label(Docstring, graph_name=graph)

    def get_function_summarizations(
        self, graph_name: str, repository_name: str = None
    ) -&gt; Dict[str, Function]:
        &#34;&#34;&#34;Converts all Function nodes into a list of tuples.

        Args:
            graph_name (str): The graph name to get function summarizations for.
            repository_name (str, optional): The specific repository within the
                                             graph to search against.

        Returns:
            List[Tuple[str, Function]
        &#34;&#34;&#34;
        if not repository_name:
            repository_name = &#34;.*&#34;

        nodes = self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:Docstring)-[:Documents]-(f:Function) WHERE n.summarization IS NOT NULL
            AND f.repository_name =~ &#39;{repository_name}&#39;
            RETURN n.summarization as `summarization`, f as `function`
            &#34;&#34;&#34;,
            graph_name=graph_name,
        )

        return dict(
            map(
                lambda x: (
                    x[&#34;summarization&#34;],
                    Function(identity=x[&#34;function&#34;].identity, **x[&#34;function&#34;]),
                ),
                nodes,
            )
        )

    def get_call_graph_by_id(self, node_id: int, graph_name: str) -&gt; CallGraph:
        &#34;&#34;&#34;Get the call graph for a Function node by its ID.

        Args:
            node_id (int): ID of the Function node.
            graph_name (str): The graph name to get function summarizations for.

        Returns:
            CallGraph
        &#34;&#34;&#34;
        results = self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (c:Function)-[r:Calls*0..1]-(f:Function)-[h:HasMethod|HasFunction]-(p)
            WHERE ID(f) = {node_id} RETURN f as `function`, c as `call`,
            r as `relationship`, p as `parent`, h as `has`, labels(p) as `parent_type`,
            labels(c) as `call_type`, type(h) as `has_type`
            &#34;&#34;&#34;,
            graph_name=graph_name,
        )

        if not results:
            return CallGraph()

        call_graph = CallGraph()

        call_graph.nodes.append(
            CallGraph.Node(
                id=results[0][&#34;function&#34;].identity,
                name=results[0][&#34;function&#34;][&#34;name&#34;],
                canonical_name=results[0][&#34;function&#34;][&#34;canonical_name&#34;],
                type=results[0][&#34;function&#34;][&#34;type&#34;],
            )
        )

        call_graph.nodes.append(
            CallGraph.Node(
                id=results[0][&#34;parent&#34;].identity,
                name=results[0][&#34;parent&#34;][&#34;name&#34;],
                canonical_name=results[0][&#34;parent&#34;][&#34;canonical_name&#34;],
                type=results[0][&#34;parent_type&#34;][0],
            )
        )

        call_graph.links.append(
            CallGraph.Relationship(
                from_id=results[0][&#34;parent&#34;].identity,
                to_id=results[0][&#34;function&#34;].identity,
                type=results[0][&#34;has_type&#34;],
            )
        )

        results = list(filter(lambda x: x[&#34;call&#34;].identity != node_id, results))
        if len(results) == 0:
            return call_graph

        call_graph.nodes.extend(
            list(
                map(
                    lambda res: CallGraph.Node(
                        id=res[&#34;call&#34;].identity,
                        name=(res[&#34;call&#34;][&#34;name&#34;]),
                        canonical_name=(
                            res[&#34;call&#34;][&#34;canonical_name&#34;]
                            if &#34;canonical_name&#34; in res
                            else res[&#34;call&#34;][&#34;name&#34;]
                        ),
                        type=res[&#34;call_type&#34;][0],
                    ),
                    results,
                )
            )
        )

        def parse_relationships(x):
            return list(
                map(
                    lambda y: CallGraph.Relationship(
                        from_id=y.start_node.identity,
                        to_id=y.end_node.identity,
                        type=&#34;Calls&#34;,
                    ),
                    x[&#34;relationship&#34;],
                )
            )

        call_graph.links.extend(
            [
                item
                for sublist in list(map(parse_relationships, results))
                for item in sublist
            ]
        )

        return call_graph

    def get_cyclical_dependencies(self, graph: str) -&gt; List[CircularDependency]:
        &#34;&#34;&#34;Get the number of cyclical dependencies in the specified graph.

        Args:
            graph (str): The name of the graph to check.

        Returns:
            List[CircularDependency]: The list of unique cyclical dependencies found.
        &#34;&#34;&#34;
        result = self.repository.execute_query(
            &#34;MATCH p=(n)-[:Imports|Calls*2..]-&gt;(n) RETURN nodes(p) as `nodes`&#34;,
            graph_name=graph,
        )

        cycles = set()

        for cycle in result:
            cycles.add(
                frozenset(
                    map(
                        lambda x: f&#34;{x[&#39;canonical_name&#39;]}.{x[&#39;extension&#39;]}&#34;,
                        cycle.get(&#34;nodes&#34;),
                    )
                )
            )

        return list(
            map(
                lambda c: CircularDependency(
                    Files=&#34; -&gt; &#34;.join(list(c) + [list(c)[0]]), Length=len(list(c))
                ),
                list(cycles),
            )
        )

    def get_missing_dependencies(self, graph: str) -&gt; List[MissingRequirement]:
        &#34;&#34;&#34;Get the number of dependencies that are missing from the requirements.

        Args:
            graph (str): The name of the graph to check.

        Returns:
            List[MissingRequirement]: The list of missing requirements found.
        &#34;&#34;&#34;
        result = self.repository.execute_query(
            &#34;MATCH (n:Package|Module) WHERE (n.inferred) = true AND  NOT (n)&lt;-[*]-()  &#34;
            &#34;RETURN DISTINCT n.canonical_name as `name`, n.repository_name as `repository`&#34;,
            graph_name=graph,
        )

        result = list(
            filter(lambda n: n[&#34;name&#34;] not in sys.stdlib_module_names, list(result))
        )

        return list(
            map(
                lambda n: MissingRequirement(
                    Package=n[&#34;name&#34;], Repository=n[&#34;repository&#34;]
                ),
                list(result),
            )
        )

    def get_readme_files(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get README files for the given graph

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        result = self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:README)-[:Contains*1..]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
            RETURN r.name as `Repository`, n.path as `File`, n.content as `Contents`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        return result

    def get_requirements(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the requirements for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (r:Repository)-[s:Requires]-&gt;(d) WHERE r.name =~ &#39;{repository}&#39;
            RETURN r.name as `Repository`, d.name as `Dependency`, s.specifications as `Specifications`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_licenses(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the licenses for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:License)-[]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
            RETURN r.name as `Repository`, n.license_type as `License`,
            n.confidence as `Confidence`, n.text as `Content`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_docstrings_full(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the docstrings and functions for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:Docstring)-[Documents]-(f:Function)-[:HasFunction|HasMethod]-()-[:Contains*1..]-(r:Repository)
            WHERE (n.short_description IS NOT NULL OR n.long_description IS NOT NULL)
            AND r.name =~ &#39;{repository}&#39; RETURN r.name as `Repository`, f.name as `Function Name`,
            n.short_description as `Docstring Summary`, n.long_description as `Doctring Body`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_summarizations(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the summarizations and functions for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:Docstring)-[:Documents]-(f)-[:HasFunction|HasMethod]-()-[:Contains*1..]-(r:Repository)
            WHERE n.summarization IS NOT NULL AND r.name =~ &#39;{repository}&#39;
            RETURN r.name as `Repository`, f.name as `Function`,
            n.summarization as `Summarization`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_files(self, graph: str, repository: Optional[str] = None) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the file names for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (m:Module)-[:Contains*1..]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
            RETURN m.name + &#39;.&#39; + m.extension as `Filename`, r.name as `Repository`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_functions_and_classes(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the function and class names for the given graph.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        return self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (n:Class|Function)-[:HasFunction|HasMethod*0..]-()-[:Contains*1..]-(r:Repository)
            WHERE r.name =~ &#39;{repository}&#39; RETURN r.name as `Repository`, n.name as `Name`, labels(n) as `Type`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

    def get_repository_metadata(
        self, graph: str, repository: Optional[str] = None
    ) -&gt; List[JSONDict]:
        &#34;&#34;&#34;Get the metadata for the given repository.

        Args:
            graph (str): The graph to search.
            repository (str, Optional): Repository to filter by.

        Returns:
            List[JSONDict]
        &#34;&#34;&#34;
        if not repository:
            repository = &#34;.*&#34;

        result = self.repository.execute_query(
            f&#34;&#34;&#34;
            MATCH (r:Repository) WHERE r.name =~ &#39;{repository}&#39;
            RETURN DISTINCT r.name as `name`, properties(r) as `properties`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        return list(
            map(
                lambda x: {
                    &#34;Repository&#34;: x[&#34;name&#34;],
                    &#34;Metadata&#34;: json.dumps(x[&#34;properties&#34;], sort_keys=True),
                },
                result,
            )
        )

    def get_repository_names(self, graph: str) -&gt; List[str]:
        &#34;&#34;&#34;Get the names of repositories in the graph.

        Args:
            graph (str): The graph to query

        Returns:
            List[str]
        &#34;&#34;&#34;
        result = self.repository.execute_query(
            &#34;&#34;&#34;
            MATCH (n:Repository) RETURN COLLECT(n.name) as `Repositories`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        return list(
            set([item for sublist in result for item in sublist[&#34;Repositories&#34;]])
        )

    def get_graph(self, graph: str) -&gt; CallGraph:
        &#34;&#34;&#34;Get an entire graph. All nodes and relationships

        Args:
            graph (str): Name of graph to fetch

        Returns:
            CallGraph
        &#34;&#34;&#34;
        call_graph = CallGraph()

        relationships = self.repository.execute_query(
            &#34;&#34;&#34;
            MATCH ()-[r]-() RETURN DISTINCT r as `relationship`, type(r) as `type`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        nodes = self.repository.execute_query(
            &#34;&#34;&#34;
            MATCH (n) RETURN DISTINCT id(n) as `identity`, 
            COALESCE(n.name, n.path, n.summarization, n.short_description, n.long_description, n.license_type) as `name`,
            labels(n) as `type`
            &#34;&#34;&#34;,
            graph_name=graph,
        )

        call_graph.links.extend(
            list(
                map(
                    lambda rel: CallGraph.Relationship(
                        from_id=rel[&#34;relationship&#34;].start_node.identity,
                        to_id=rel[&#34;relationship&#34;].end_node.identity,
                        type=rel[&#34;type&#34;],
                    ),
                    relationships,
                )
            )
        )

        call_graph.nodes.extend(
            list(
                map(
                    lambda node: CallGraph.Node(
                        id=node[&#34;identity&#34;],
                        name=node[&#34;name&#34;],
                        canonical_name=&#34;&#34;,
                        type=node[&#34;type&#34;][0],
                    ),
                    nodes,
                )
            )
        )

        return call_graph</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="repograph.entities.graph.service.GraphService.metadata"><code class="name">var <span class="ident">metadata</span> : <a title="repograph.entities.metadata.service.MetadataService" href="../metadata/service.html#repograph.entities.metadata.service.MetadataService">MetadataService</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="repograph.entities.graph.service.GraphService.repository"><code class="name">var <span class="ident">repository</span> : <a title="repograph.entities.graph.repository.GraphRepository" href="repository.html#repograph.entities.graph.repository.GraphRepository">GraphRepository</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="repograph.entities.graph.service.GraphService.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, *args: <a title="repograph.entities.graph.models.base.BaseSubgraph" href="models/base.html#repograph.entities.graph.models.base.BaseSubgraph">BaseSubgraph</a>, tx: py2neo.database.Transaction = None, graph_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add nodes/relationships to the graph</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>BaseSubgraph</code></dt>
<dd>Nodes and/or relationships</dd>
<dt><strong><code>tx</code></strong> :&ensp;<code>Transaction</code></dt>
<dd>The optional transaction object to use</dd>
<dt><strong><code>graph_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The optional graph name to obtain a transaction for if no tx is used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, *args: BaseSubgraph, tx: Transaction = None, graph_name=None):
    &#34;&#34;&#34;Add nodes/relationships to the graph

    Args:
        *args (BaseSubgraph): Nodes and/or relationships
        tx (Transaction): The optional transaction object to use
        graph_name (str): The optional graph name to obtain a transaction for if no tx is used.
    &#34;&#34;&#34;
    self.repository.add(*args, tx=tx, graph_name=graph_name)</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.bulk_add"><code class="name flex">
<span>def <span class="ident">bulk_add</span></span>(<span>self, nodes: List[<a title="repograph.entities.graph.models.base.Node" href="models/base.html#repograph.entities.graph.models.base.Node">Node</a>], relationships: List[<a title="repograph.entities.graph.models.base.Relationship" href="models/base.html#repograph.entities.graph.models.base.Relationship">Relationship</a>], graph_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Bulk add nodes and relationships.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>List[Node]</code></dt>
<dd>Nodes to add.</dd>
<dt><strong><code>relationships</code></strong> :&ensp;<code>List[Relationship]</code></dt>
<dd>Relationships to add.</dd>
<dt><strong><code>graph_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The optional graph name to obtain a transaction for.</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_add(
    self, nodes: List[Node], relationships: List[Relationship], graph_name: str
):
    &#34;&#34;&#34;Bulk add nodes and relationships.

    Args:
        nodes (List[Node]): Nodes to add.
        relationships (List[Relationship]): Relationships to add.
        graph_name (str): The optional graph name to obtain a transaction for.

    Return:
        None
    &#34;&#34;&#34;
    self.repository.add(*nodes, *relationships, graph_name=graph_name)</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.create_graph"><code class="name flex">
<span>def <span class="ident">create_graph</span></span>(<span>self, name: str, description: str, system_tx: neo4j._sync.work.transaction.Transaction, metadata_tx: sqlite3.Connection) ‑> <a title="repograph.entities.metadata.models.Graph" href="../metadata/models.html#repograph.entities.metadata.models.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new graph.</p>
<h2 id="args">Args</h2>
<p>name:
description:
system_tx:
metadata_tx:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Graph</code></dt>
<dd>Created Graph object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_graph(
    self,
    name: str,
    description: str,
    system_tx: neo4jTransaction,
    metadata_tx: Connection,
) -&gt; Graph:
    &#34;&#34;&#34;Create a new graph.

    Args:
        name:
        description:
        system_tx:
        metadata_tx:

    Returns:
        Graph: Created Graph object
    &#34;&#34;&#34;
    if not re.match(r&#34;^[a-z,A-Z,0-9][a-z,A-Z,0-9]{2,63}$&#34;, name.lower()):
        raise InvalidGraphNameError(name)

    graph = Graph(
        neo4j_name=name.lower(),
        name=name,
        description=description,
        created=datetime.datetime.now(),
    )

    self.repository.create_graph(graph.neo4j_name, system_tx)
    self.metadata.register_graph(graph, metadata_tx)

    return graph</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.delete_graph"><code class="name flex">
<span>def <span class="ident">delete_graph</span></span>(<span>self, name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a graph</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the graph to delete</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_graph(self, name: str) -&gt; None:
    &#34;&#34;&#34;Delete a graph

    Args:
        name (str): Name of the graph to delete

    Returns:
        None
    &#34;&#34;&#34;
    self.repository.delete_graph(name)
    self.metadata.delete_graph(name)</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_call_graph_by_id"><code class="name flex">
<span>def <span class="ident">get_call_graph_by_id</span></span>(<span>self, node_id: int, graph_name: str) ‑> <a title="repograph.entities.graph.models.graph.CallGraph" href="models/graph.html#repograph.entities.graph.models.graph.CallGraph">CallGraph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the call graph for a Function node by its ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the Function node.</dd>
<dt><strong><code>graph_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph name to get function summarizations for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>CallGraph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_call_graph_by_id(self, node_id: int, graph_name: str) -&gt; CallGraph:
    &#34;&#34;&#34;Get the call graph for a Function node by its ID.

    Args:
        node_id (int): ID of the Function node.
        graph_name (str): The graph name to get function summarizations for.

    Returns:
        CallGraph
    &#34;&#34;&#34;
    results = self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (c:Function)-[r:Calls*0..1]-(f:Function)-[h:HasMethod|HasFunction]-(p)
        WHERE ID(f) = {node_id} RETURN f as `function`, c as `call`,
        r as `relationship`, p as `parent`, h as `has`, labels(p) as `parent_type`,
        labels(c) as `call_type`, type(h) as `has_type`
        &#34;&#34;&#34;,
        graph_name=graph_name,
    )

    if not results:
        return CallGraph()

    call_graph = CallGraph()

    call_graph.nodes.append(
        CallGraph.Node(
            id=results[0][&#34;function&#34;].identity,
            name=results[0][&#34;function&#34;][&#34;name&#34;],
            canonical_name=results[0][&#34;function&#34;][&#34;canonical_name&#34;],
            type=results[0][&#34;function&#34;][&#34;type&#34;],
        )
    )

    call_graph.nodes.append(
        CallGraph.Node(
            id=results[0][&#34;parent&#34;].identity,
            name=results[0][&#34;parent&#34;][&#34;name&#34;],
            canonical_name=results[0][&#34;parent&#34;][&#34;canonical_name&#34;],
            type=results[0][&#34;parent_type&#34;][0],
        )
    )

    call_graph.links.append(
        CallGraph.Relationship(
            from_id=results[0][&#34;parent&#34;].identity,
            to_id=results[0][&#34;function&#34;].identity,
            type=results[0][&#34;has_type&#34;],
        )
    )

    results = list(filter(lambda x: x[&#34;call&#34;].identity != node_id, results))
    if len(results) == 0:
        return call_graph

    call_graph.nodes.extend(
        list(
            map(
                lambda res: CallGraph.Node(
                    id=res[&#34;call&#34;].identity,
                    name=(res[&#34;call&#34;][&#34;name&#34;]),
                    canonical_name=(
                        res[&#34;call&#34;][&#34;canonical_name&#34;]
                        if &#34;canonical_name&#34; in res
                        else res[&#34;call&#34;][&#34;name&#34;]
                    ),
                    type=res[&#34;call_type&#34;][0],
                ),
                results,
            )
        )
    )

    def parse_relationships(x):
        return list(
            map(
                lambda y: CallGraph.Relationship(
                    from_id=y.start_node.identity,
                    to_id=y.end_node.identity,
                    type=&#34;Calls&#34;,
                ),
                x[&#34;relationship&#34;],
            )
        )

    call_graph.links.extend(
        [
            item
            for sublist in list(map(parse_relationships, results))
            for item in sublist
        ]
    )

    return call_graph</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_cyclical_dependencies"><code class="name flex">
<span>def <span class="ident">get_cyclical_dependencies</span></span>(<span>self, graph: str) ‑> List[<a title="repograph.entities.graph.models.graph.CircularDependency" href="models/graph.html#repograph.entities.graph.models.graph.CircularDependency">CircularDependency</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the number of cyclical dependencies in the specified graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the graph to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[CircularDependency]</code></dt>
<dd>The list of unique cyclical dependencies found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cyclical_dependencies(self, graph: str) -&gt; List[CircularDependency]:
    &#34;&#34;&#34;Get the number of cyclical dependencies in the specified graph.

    Args:
        graph (str): The name of the graph to check.

    Returns:
        List[CircularDependency]: The list of unique cyclical dependencies found.
    &#34;&#34;&#34;
    result = self.repository.execute_query(
        &#34;MATCH p=(n)-[:Imports|Calls*2..]-&gt;(n) RETURN nodes(p) as `nodes`&#34;,
        graph_name=graph,
    )

    cycles = set()

    for cycle in result:
        cycles.add(
            frozenset(
                map(
                    lambda x: f&#34;{x[&#39;canonical_name&#39;]}.{x[&#39;extension&#39;]}&#34;,
                    cycle.get(&#34;nodes&#34;),
                )
            )
        )

    return list(
        map(
            lambda c: CircularDependency(
                Files=&#34; -&gt; &#34;.join(list(c) + [list(c)[0]]), Length=len(list(c))
            ),
            list(cycles),
        )
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_docstrings"><code class="name flex">
<span>def <span class="ident">get_docstrings</span></span>(<span>self, graph: str) ‑> List[<a title="repograph.entities.graph.models.base.Node" href="models/base.html#repograph.entities.graph.models.base.Node">Node</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get Docstring nodes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>Graph name to query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[Node]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_docstrings(self, graph: str) -&gt; List[Node]:
    &#34;&#34;&#34;Get Docstring nodes.

    Args:
        graph (str): Graph name to query.

    Returns:
        List[Node]
    &#34;&#34;&#34;
    return self.repository.get_all_nodes_by_label(Docstring, graph_name=graph)</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_docstrings_full"><code class="name flex">
<span>def <span class="ident">get_docstrings_full</span></span>(<span>self, graph: str, repository: Optional[str] = None) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the docstrings and functions for the given graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to search.</dd>
<dt><strong><code>repository</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Repository to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[JSONDict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_docstrings_full(
    self, graph: str, repository: Optional[str] = None
) -&gt; List[JSONDict]:
    &#34;&#34;&#34;Get the docstrings and functions for the given graph.

    Args:
        graph (str): The graph to search.
        repository (str, Optional): Repository to filter by.

    Returns:
        List[JSONDict]
    &#34;&#34;&#34;
    if not repository:
        repository = &#34;.*&#34;

    return self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (n:Docstring)-[Documents]-(f:Function)-[:HasFunction|HasMethod]-()-[:Contains*1..]-(r:Repository)
        WHERE (n.short_description IS NOT NULL OR n.long_description IS NOT NULL)
        AND r.name =~ &#39;{repository}&#39; RETURN r.name as `Repository`, f.name as `Function Name`,
        n.short_description as `Docstring Summary`, n.long_description as `Doctring Body`
        &#34;&#34;&#34;,
        graph_name=graph,
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_files"><code class="name flex">
<span>def <span class="ident">get_files</span></span>(<span>self, graph: str, repository: Optional[str] = None) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the file names for the given graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to search.</dd>
<dt><strong><code>repository</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Repository to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[JSONDict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_files(self, graph: str, repository: Optional[str] = None) -&gt; List[JSONDict]:
    &#34;&#34;&#34;Get the file names for the given graph.

    Args:
        graph (str): The graph to search.
        repository (str, Optional): Repository to filter by.

    Returns:
        List[JSONDict]
    &#34;&#34;&#34;
    if not repository:
        repository = &#34;.*&#34;

    return self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (m:Module)-[:Contains*1..]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
        RETURN m.name + &#39;.&#39; + m.extension as `Filename`, r.name as `Repository`
        &#34;&#34;&#34;,
        graph_name=graph,
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_function_summarizations"><code class="name flex">
<span>def <span class="ident">get_function_summarizations</span></span>(<span>self, graph_name: str, repository_name: str = None) ‑> Dict[str, <a title="repograph.entities.graph.models.nodes.Function" href="models/nodes.html#repograph.entities.graph.models.nodes.Function">Function</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts all Function nodes into a list of tuples.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph name to get function summarizations for.</dd>
<dt><strong><code>repository_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The specific repository within the
graph to search against.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[Tuple[str, Function]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_summarizations(
    self, graph_name: str, repository_name: str = None
) -&gt; Dict[str, Function]:
    &#34;&#34;&#34;Converts all Function nodes into a list of tuples.

    Args:
        graph_name (str): The graph name to get function summarizations for.
        repository_name (str, optional): The specific repository within the
                                         graph to search against.

    Returns:
        List[Tuple[str, Function]
    &#34;&#34;&#34;
    if not repository_name:
        repository_name = &#34;.*&#34;

    nodes = self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (n:Docstring)-[:Documents]-(f:Function) WHERE n.summarization IS NOT NULL
        AND f.repository_name =~ &#39;{repository_name}&#39;
        RETURN n.summarization as `summarization`, f as `function`
        &#34;&#34;&#34;,
        graph_name=graph_name,
    )

    return dict(
        map(
            lambda x: (
                x[&#34;summarization&#34;],
                Function(identity=x[&#34;function&#34;].identity, **x[&#34;function&#34;]),
            ),
            nodes,
        )
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_functions_and_classes"><code class="name flex">
<span>def <span class="ident">get_functions_and_classes</span></span>(<span>self, graph: str, repository: Optional[str] = None) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the function and class names for the given graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to search.</dd>
<dt><strong><code>repository</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Repository to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[JSONDict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_functions_and_classes(
    self, graph: str, repository: Optional[str] = None
) -&gt; List[JSONDict]:
    &#34;&#34;&#34;Get the function and class names for the given graph.

    Args:
        graph (str): The graph to search.
        repository (str, Optional): Repository to filter by.

    Returns:
        List[JSONDict]
    &#34;&#34;&#34;
    if not repository:
        repository = &#34;.*&#34;

    return self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (n:Class|Function)-[:HasFunction|HasMethod*0..]-()-[:Contains*1..]-(r:Repository)
        WHERE r.name =~ &#39;{repository}&#39; RETURN r.name as `Repository`, n.name as `Name`, labels(n) as `Type`
        &#34;&#34;&#34;,
        graph_name=graph,
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_graph"><code class="name flex">
<span>def <span class="ident">get_graph</span></span>(<span>self, graph: str) ‑> <a title="repograph.entities.graph.models.graph.CallGraph" href="models/graph.html#repograph.entities.graph.models.graph.CallGraph">CallGraph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get an entire graph. All nodes and relationships</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of graph to fetch</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>CallGraph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_graph(self, graph: str) -&gt; CallGraph:
    &#34;&#34;&#34;Get an entire graph. All nodes and relationships

    Args:
        graph (str): Name of graph to fetch

    Returns:
        CallGraph
    &#34;&#34;&#34;
    call_graph = CallGraph()

    relationships = self.repository.execute_query(
        &#34;&#34;&#34;
        MATCH ()-[r]-() RETURN DISTINCT r as `relationship`, type(r) as `type`
        &#34;&#34;&#34;,
        graph_name=graph,
    )

    nodes = self.repository.execute_query(
        &#34;&#34;&#34;
        MATCH (n) RETURN DISTINCT id(n) as `identity`, 
        COALESCE(n.name, n.path, n.summarization, n.short_description, n.long_description, n.license_type) as `name`,
        labels(n) as `type`
        &#34;&#34;&#34;,
        graph_name=graph,
    )

    call_graph.links.extend(
        list(
            map(
                lambda rel: CallGraph.Relationship(
                    from_id=rel[&#34;relationship&#34;].start_node.identity,
                    to_id=rel[&#34;relationship&#34;].end_node.identity,
                    type=rel[&#34;type&#34;],
                ),
                relationships,
            )
        )
    )

    call_graph.nodes.extend(
        list(
            map(
                lambda node: CallGraph.Node(
                    id=node[&#34;identity&#34;],
                    name=node[&#34;name&#34;],
                    canonical_name=&#34;&#34;,
                    type=node[&#34;type&#34;][0],
                ),
                nodes,
            )
        )
    )

    return call_graph</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_licenses"><code class="name flex">
<span>def <span class="ident">get_licenses</span></span>(<span>self, graph: str, repository: Optional[str] = None) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the licenses for the given graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to search.</dd>
<dt><strong><code>repository</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Repository to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[JSONDict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_licenses(
    self, graph: str, repository: Optional[str] = None
) -&gt; List[JSONDict]:
    &#34;&#34;&#34;Get the licenses for the given graph.

    Args:
        graph (str): The graph to search.
        repository (str, Optional): Repository to filter by.

    Returns:
        List[JSONDict]
    &#34;&#34;&#34;
    if not repository:
        repository = &#34;.*&#34;

    return self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (n:License)-[]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
        RETURN r.name as `Repository`, n.license_type as `License`,
        n.confidence as `Confidence`, n.text as `Content`
        &#34;&#34;&#34;,
        graph_name=graph,
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_missing_dependencies"><code class="name flex">
<span>def <span class="ident">get_missing_dependencies</span></span>(<span>self, graph: str) ‑> List[<a title="repograph.entities.graph.models.graph.MissingRequirement" href="models/graph.html#repograph.entities.graph.models.graph.MissingRequirement">MissingRequirement</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the number of dependencies that are missing from the requirements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the graph to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[MissingRequirement]</code></dt>
<dd>The list of missing requirements found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_missing_dependencies(self, graph: str) -&gt; List[MissingRequirement]:
    &#34;&#34;&#34;Get the number of dependencies that are missing from the requirements.

    Args:
        graph (str): The name of the graph to check.

    Returns:
        List[MissingRequirement]: The list of missing requirements found.
    &#34;&#34;&#34;
    result = self.repository.execute_query(
        &#34;MATCH (n:Package|Module) WHERE (n.inferred) = true AND  NOT (n)&lt;-[*]-()  &#34;
        &#34;RETURN DISTINCT n.canonical_name as `name`, n.repository_name as `repository`&#34;,
        graph_name=graph,
    )

    result = list(
        filter(lambda n: n[&#34;name&#34;] not in sys.stdlib_module_names, list(result))
    )

    return list(
        map(
            lambda n: MissingRequirement(
                Package=n[&#34;name&#34;], Repository=n[&#34;repository&#34;]
            ),
            list(result),
        )
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_readme_files"><code class="name flex">
<span>def <span class="ident">get_readme_files</span></span>(<span>self, graph: str, repository: Optional[str] = None) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get README files for the given graph</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to search.</dd>
<dt><strong><code>repository</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Repository to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[JSONDict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_readme_files(
    self, graph: str, repository: Optional[str] = None
) -&gt; List[JSONDict]:
    &#34;&#34;&#34;Get README files for the given graph

    Args:
        graph (str): The graph to search.
        repository (str, Optional): Repository to filter by.

    Returns:
        List[JSONDict]
    &#34;&#34;&#34;
    if not repository:
        repository = &#34;.*&#34;

    result = self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (n:README)-[:Contains*1..]-(r:Repository) WHERE r.name =~ &#39;{repository}&#39;
        RETURN r.name as `Repository`, n.path as `File`, n.content as `Contents`
        &#34;&#34;&#34;,
        graph_name=graph,
    )

    return result</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_repository_metadata"><code class="name flex">
<span>def <span class="ident">get_repository_metadata</span></span>(<span>self, graph: str, repository: Optional[str] = None) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the metadata for the given repository.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to search.</dd>
<dt><strong><code>repository</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Repository to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[JSONDict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_repository_metadata(
    self, graph: str, repository: Optional[str] = None
) -&gt; List[JSONDict]:
    &#34;&#34;&#34;Get the metadata for the given repository.

    Args:
        graph (str): The graph to search.
        repository (str, Optional): Repository to filter by.

    Returns:
        List[JSONDict]
    &#34;&#34;&#34;
    if not repository:
        repository = &#34;.*&#34;

    result = self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (r:Repository) WHERE r.name =~ &#39;{repository}&#39;
        RETURN DISTINCT r.name as `name`, properties(r) as `properties`
        &#34;&#34;&#34;,
        graph_name=graph,
    )

    return list(
        map(
            lambda x: {
                &#34;Repository&#34;: x[&#34;name&#34;],
                &#34;Metadata&#34;: json.dumps(x[&#34;properties&#34;], sort_keys=True),
            },
            result,
        )
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_repository_names"><code class="name flex">
<span>def <span class="ident">get_repository_names</span></span>(<span>self, graph: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the names of repositories in the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to query</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[str]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_repository_names(self, graph: str) -&gt; List[str]:
    &#34;&#34;&#34;Get the names of repositories in the graph.

    Args:
        graph (str): The graph to query

    Returns:
        List[str]
    &#34;&#34;&#34;
    result = self.repository.execute_query(
        &#34;&#34;&#34;
        MATCH (n:Repository) RETURN COLLECT(n.name) as `Repositories`
        &#34;&#34;&#34;,
        graph_name=graph,
    )

    return list(
        set([item for sublist in result for item in sublist[&#34;Repositories&#34;]])
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_requirements"><code class="name flex">
<span>def <span class="ident">get_requirements</span></span>(<span>self, graph: str, repository: Optional[str] = None) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the requirements for the given graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to search.</dd>
<dt><strong><code>repository</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Repository to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[JSONDict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_requirements(
    self, graph: str, repository: Optional[str] = None
) -&gt; List[JSONDict]:
    &#34;&#34;&#34;Get the requirements for the given graph.

    Args:
        graph (str): The graph to search.
        repository (str, Optional): Repository to filter by.

    Returns:
        List[JSONDict]
    &#34;&#34;&#34;
    if not repository:
        repository = &#34;.*&#34;

    return self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (r:Repository)-[s:Requires]-&gt;(d) WHERE r.name =~ &#39;{repository}&#39;
        RETURN r.name as `Repository`, d.name as `Dependency`, s.specifications as `Specifications`
        &#34;&#34;&#34;,
        graph_name=graph,
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_summarizations"><code class="name flex">
<span>def <span class="ident">get_summarizations</span></span>(<span>self, graph: str, repository: Optional[str] = None) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the summarizations and functions for the given graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph to search.</dd>
<dt><strong><code>repository</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Repository to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List[JSONDict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_summarizations(
    self, graph: str, repository: Optional[str] = None
) -&gt; List[JSONDict]:
    &#34;&#34;&#34;Get the summarizations and functions for the given graph.

    Args:
        graph (str): The graph to search.
        repository (str, Optional): Repository to filter by.

    Returns:
        List[JSONDict]
    &#34;&#34;&#34;
    if not repository:
        repository = &#34;.*&#34;

    return self.repository.execute_query(
        f&#34;&#34;&#34;
        MATCH (n:Docstring)-[:Documents]-(f)-[:HasFunction|HasMethod]-()-[:Contains*1..]-(r:Repository)
        WHERE n.summarization IS NOT NULL AND r.name =~ &#39;{repository}&#39;
        RETURN r.name as `Repository`, f.name as `Function`,
        n.summarization as `Summarization`
        &#34;&#34;&#34;,
        graph_name=graph,
    )</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_summary"><code class="name flex">
<span>def <span class="ident">get_summary</span></span>(<span>self, graph_name: str) ‑> <a title="repograph.entities.graph.models.graph.GraphSummary" href="models/graph.html#repograph.entities.graph.models.graph.GraphSummary">GraphSummary</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a summary of the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The graph name to get summary for.</dd>
</dl>
<h2 id="return">Return</h2>
<p>GraphSummary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_summary(self, graph_name: str) -&gt; GraphSummary:
    &#34;&#34;&#34;Calculate a summary of the graph.

    Args:
        graph_name (str): The graph name to get summary for.

    Return:
        GraphSummary
    &#34;&#34;&#34;
    if not self.repository.has_nodes(graph_name=graph_name):
        log.warning(&#34;Graph has no nodes&#34;)
        return GraphSummary()

    summary = GraphSummary(is_empty=False)

    # Nodes and relationships totals
    nodes, relationships = self.repository.get_number_of_nodes_and_relationships(
        graph_name=graph_name
    )
    summary.nodes_total = nodes
    summary.relationships_total = relationships

    # Repositories
    summary.repositories = len(
        self.repository.get_all_nodes_by_label(Repository, graph_name=graph_name)
    )

    # Packages
    summary.packages = len(
        self.repository.get_all_nodes_by_label(Package, graph_name=graph_name)
    )

    # Modules
    summary.modules = len(
        self.repository.get_all_nodes_by_label(Module, graph_name=graph_name)
    )

    # Classes
    summary.classes = len(
        self.repository.get_all_nodes_by_label(Class, graph_name=graph_name)
    )

    # Functions
    summary.functions = len(
        self.repository.get_all_nodes_by_label(Function, graph_name=graph_name)
    )

    # README
    summary.readmes = len(
        self.repository.get_all_nodes_by_label(README, graph_name=graph_name)
    )

    return summary</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_system_transaction"><code class="name flex">
<span>def <span class="ident">get_system_transaction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def get_system_transaction(self):
    tx = self.repository.get_driver_transaction()
    metadata_tx = self.metadata.get_transaction()
    try:
        yield tx, metadata_tx
        tx.commit()
        metadata_tx.commit()
    except Exception as e:
        log.error(
            &#34;An error occurred. Rolling back system graph and metadata transactions!\n%s&#34;,
            str(e),
        )
        tx.rollback()
        metadata_tx.rollback()
        raise e</code></pre>
</details>
</dd>
<dt id="repograph.entities.graph.service.GraphService.get_transaction"><code class="name flex">
<span>def <span class="ident">get_transaction</span></span>(<span>self, graph_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain a Neo4j transaction for a given graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the graph</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def get_transaction(self, graph_name):
    &#34;&#34;&#34;Obtain a Neo4j transaction for a given graph.

    Args:
        graph_name (str): The name of the graph
    &#34;&#34;&#34;
    tx = self.repository.get_transaction(graph_name=graph_name)
    try:
        yield tx
        log.info(&#34;Committing changes to graph...&#34;)
        tx.commit()
        log.info(&#34;Done!&#34;)
    except Exception as e:
        log.error(&#34;An error occurred. Rolling back graph transaction!\n&#34; + str(e))
        traceback.print_exc()
        tx.rollback()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="repograph.entities.graph" href="index.html">repograph.entities.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="repograph.entities.graph.service.GraphService" href="#repograph.entities.graph.service.GraphService">GraphService</a></code></h4>
<ul class="">
<li><code><a title="repograph.entities.graph.service.GraphService.add" href="#repograph.entities.graph.service.GraphService.add">add</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.bulk_add" href="#repograph.entities.graph.service.GraphService.bulk_add">bulk_add</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.create_graph" href="#repograph.entities.graph.service.GraphService.create_graph">create_graph</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.delete_graph" href="#repograph.entities.graph.service.GraphService.delete_graph">delete_graph</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_call_graph_by_id" href="#repograph.entities.graph.service.GraphService.get_call_graph_by_id">get_call_graph_by_id</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_cyclical_dependencies" href="#repograph.entities.graph.service.GraphService.get_cyclical_dependencies">get_cyclical_dependencies</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_docstrings" href="#repograph.entities.graph.service.GraphService.get_docstrings">get_docstrings</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_docstrings_full" href="#repograph.entities.graph.service.GraphService.get_docstrings_full">get_docstrings_full</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_files" href="#repograph.entities.graph.service.GraphService.get_files">get_files</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_function_summarizations" href="#repograph.entities.graph.service.GraphService.get_function_summarizations">get_function_summarizations</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_functions_and_classes" href="#repograph.entities.graph.service.GraphService.get_functions_and_classes">get_functions_and_classes</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_graph" href="#repograph.entities.graph.service.GraphService.get_graph">get_graph</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_licenses" href="#repograph.entities.graph.service.GraphService.get_licenses">get_licenses</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_missing_dependencies" href="#repograph.entities.graph.service.GraphService.get_missing_dependencies">get_missing_dependencies</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_readme_files" href="#repograph.entities.graph.service.GraphService.get_readme_files">get_readme_files</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_repository_metadata" href="#repograph.entities.graph.service.GraphService.get_repository_metadata">get_repository_metadata</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_repository_names" href="#repograph.entities.graph.service.GraphService.get_repository_names">get_repository_names</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_requirements" href="#repograph.entities.graph.service.GraphService.get_requirements">get_requirements</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_summarizations" href="#repograph.entities.graph.service.GraphService.get_summarizations">get_summarizations</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_summary" href="#repograph.entities.graph.service.GraphService.get_summary">get_summary</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_system_transaction" href="#repograph.entities.graph.service.GraphService.get_system_transaction">get_system_transaction</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.get_transaction" href="#repograph.entities.graph.service.GraphService.get_transaction">get_transaction</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.metadata" href="#repograph.entities.graph.service.GraphService.metadata">metadata</a></code></li>
<li><code><a title="repograph.entities.graph.service.GraphService.repository" href="#repograph.entities.graph.service.GraphService.repository">repository</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>